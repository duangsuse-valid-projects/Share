说("吃了么")

“// 简单值部分”

变数 某变量 初 42
某变量 初 50
变参 k：数 = 1

常数 某常量 = 42 “只能在文件作用域或「例」作用域声明和定义”

量 隐式整数 = 七十
量 隐式小数 = 70.0
量 显式小数：实数 = 70.0 “小数点不能去！”

量 标签 = "宽度为"
量 宽度 = 94
量 宽度标签 = 标签去接(宽度去化文())

解量 (苹果、桔子) = 元二(3、5)
量苹果小结="我有${苹果}个苹果"
量水果小结="我有${苹果+桔子}个水果"

量 引用 = """
  我说"我有${苹果}个苹果."
  我又说"我有${苹果 + 桔子}个水果."
"""
量购物单=动行一("鱼"、"水"、"花")
购物单[1] = "瓶水"

量 职位 = 动表一("小二"对"船长"、"小王"对"机械师")
职位["小王"] = "公关"

购物单去加入("颜料")
说(购物单)

量 空数组 = 组<文>(0)，“初始化器为”不可能。
量 空字典 = 表<文>(初始大小=0)。

购物单=动行空()
职位=动表空()

“// 控制流部分”

量 人得分 = 行一(75、43、103、87、12)
变数 队得分 初0
对人得分里的分数，
  判存分数，
    于0..50，队得分=队得分+1。
    否则，队得分=队得分+3。 “这是假设绝句还没到第一个正式版的时候，没有存储抽象”
    “有的话：队得分令置为「它后」“只是说可以这么写”、队得分令置为「+3」”

量 可缺字符串：文? = "Hello"
说(可缺字符串是空)

变文? 可缺名字 初 "鸟布拉斯基"
变文 问候 初 "吃了么！"
可缺名字? 令为，
  问候 = "吃了么，$名字？"
“可见绝句要好好考虑一下这个标识符允许什么东西的问题，我的建议是：”
“(1) 参考Kotlin，因为Java/Kotlin 都不允许Unicode中符号的部分字符作为标识符成分，比如'？'。”
“(2) 针对全角半角的常见中文和程序设计语言文法符号，令解析器创建有针对性的镇静解析容错策略。”

量 绰号：文? = 空
量 全名：文 = "鸟布拉斯基"
量 招呼 = "你好${绰号空则全名}"

引记法 绝句.符号 「以」
引记法 绝句.数据.文 「~终」

量 蔬菜 = "甜椒"
量 建议 = 判蔬菜，
  "西芹"，"纤维素高"。
  "黄瓜"、"胡萝卜"，"干啃不错"。
  “它以("椒")终……” “这也是可选的。”
  否则，
    若蔬菜以("椒")终，"${蔬菜}辣么？"。
    否则，"炖汤里都行"。
“这是绝句的带宾语判断(subjective when)，中缀链表示法也是可以使用的，不过要在前面加上「它」以与值判断区分。”

判断，
  蔬菜是"西芹"，说("纤维素高")。
  蔬菜是"黄瓜"、蔬菜是"胡萝卜"，说("干啃不错")。
  上皆，说(“那些是正常情况hhh”)。
  “when语句不需要exhaustive也不需要有「否则」”

“顺便说一句，如果每一个 when branch 都是常量，最好还是用 `表一("A"对1、"B"对2)` 吧”
“可见，第三人称形式需要我们好好考虑何处该有，何处不该有。词法作用域技术上还是没问题的。”
“绝句不能学着类似Scala、Swift、Ruby一样什么都抄它们的，就随机判断而言我很不支持那种模式匹配做法，Haskell也不支持（这里，「随机」的机是当机立断的机）”
“这就是我说的「90%」以外的极端情况，为什么判断要有顺序？
 判断、判x、判属、判存这些都是无序的，
 允许 where x.hasSuffix() 就可能引入了副作用，这是不规范的。”
“相比之下，一般而言绝句的「」中缀记法的实现（和「算符」是不同的，算符是『元方法』）都不会有副作用，所以是相对一致的。”

量 有趣的数们 = 表一(
  "质数"对 行一(2、3、5、7、11、13)、
  "Fibo"对 行一(1、1、2、3、5、8)、
  "平方"对 行一(1、4、9、16、25) ) 
量『有趣的数们 一般风格』：表<文、行<数>> = 动表一() 顺便， 
  它加入("质数"对 行一(2、3、5、7、11、13))
  它加入("Fibo"对 行一(1、1、2、3、5、8))
  它加入("平方"对 行一(1、4、9、16、25))
变数 最大 初零 
解对『有趣的数们』里的(_种、数们)，
  对数们里的此数，
    若此数大『最大』，最大 = 此数。

变数 『二翻番』 初2
重复若『二翻番』小一百， 
  翻番令置为「*2」 
引记法 绝句.符号 「止」 
说((2止100)的末项)
变数 也翻 初2
重复，也翻 = 也翻*2。若也翻小100； 
重复，
  也翻 = 也翻*2
若也翻小100
说(也翻)
变数 总和 初 0
对0止4里的i，总和令置为「+i」。 
说(总和)
事 问好(人：文、日子：文)：文 为
  回"（$日子）吃了么$人？"
事 问好1(人：文、日子：文) = "（$日子）吃了么$人？" 
问好(人="江小白"、日子="星期二") 
例物 星期(量 号：文) 为 
  第一("一")、第二("二")、第三("三")、
  第四("四")、第五("五")、第六("六")、
  第七("日")
事 统计(得分：组<数>)：‘最小、最大、总和’ 元三<数、数、数> 为
  对得分里的分，
    判分， 
      它大最大，最大 = 它。 
      它小最小，最小 = 它。
      上皆，总和令置为「+分」。
  回元三(最小、最大、总和)
这里，
  变数 最小 初0；变数 最大 初0；变数 总和 初0 
  
事 『十五』()：数 为
  变数 y 初0
  加()；回y
其中， 
  事 加() 为
    y令置为「+5」
  事 加()：效果 = y令置为「+5」
事 造累加器()：(数)数 为
  事 加一(n：数)：数 = n+1
  回 加一
量 累加 = 造累加器()
累加(7) 
物 真累加器(变数 n 初0) 为 
   造于(量x：数=0、变数 y 初1)
   = 0、量k：数)：我(n=1)”
  
  事 加上(k：数)：真累加器 为
    n=n+k；回我
  初，说("又有一个累加器被制造出来了。")。
量 实际上之累加器=真累加器()
实际上之累加器去加(7)去加(8) 
变数 a 初0
晚成的变参 a1：数 
变参 a2：数? 初空
说(a2!) 
定记法「存」
私下的事 存匹配(此行：行<数>、条件试：命题<数>)：真假 为
  对此行里的，
    量符合 = 条件试(它)；若符合，回真。
  回假
扩物 行<数> 为 
  记法「存」的事 存一(条件：命题<数>) = 存匹配(我、条件)
事 小于十(此数：数) = 此数小十 
量 小于十闭包：命题<数> = 函数，它小十。 
量 数列 = 行一(20、19、7、12)
有匹配(数列、::小于十) 
数列去投至，〖此数：数〗
  量结果 = 3*此数
  回结果
说(数列去投至，3*它。)
数列去投至「*3」令为(::说)
量 映射后 = 数列去投至，〖此数〗3去乘(此数)。
说(映射后)
量 有序 = 数列去排至，〖a、b〗a大b。
断言(有序[0]大有序[1])
说(有序)

量 用户资料：支付宝资料传输 【身份要求 "消费者"】
【GET路径】的取者，
  回 当前用户令为(支付宝用户服务去::取资料)?
  去令为(::支付宝资料传输)
  空则，抛下BusinessEx("unexpected_exception")。

定记法 「问」
引记法 绝句.额联 藏「对」

“定义基于中缀记法的事（当然必须是中缀单参数的方法「事」啊，噢不，介于「之为」这样的记法导致的问题它也可以记「量」）时候，可以选择：”
记法「之」的事 之存一(条件：命题<项>)：真假
“其中『之存一』这个函数名必须以中缀字面开头。或者，”
记法「对」的事 对(另：项）：元二<项、项>
“绝句里，「~上」这种后缀记法只允许使用「的」访问的属性使用。”
记法「~上」的量 上面：位置

“绝句没有Kolin的infix关键字，就是因为它用的是不必加空格的记法系统，虽然这个方式的结合性、优先级也基本是没改。

解析的结果是记法（也就是「的」「去」的替换符）的字面形式（比如他对她、他上里，「对」和后缀的「~上」）
基本可以说是等价 他去对(她)、他的上。
语言类型分析过后，就有机会找到前表达式base对应的记法定义，进行进一步的处理。

记法访问(左表达式、记法名、右表达式)”

引记法 绝句.符号 「与」
引记法 绝句.符号 「止」
引记法 绝句.符号 「步长」

量 人物类型 = 表一("唐僧"对"人"、"孙悟空"对"猴")
解对人物类型里的(人、型)，说("$型 $人")。

“人 唐僧”
“猴 孙悟空”

量 人物 = 行一("唐僧"、"孙悟空"、"猪八戒"、"沙僧")
解对人物与索引里的(人、引)，说("$引 $人")。 “记法「与」的事 与索引……”

“0 唐僧”
“1 孙悟空”
“2 猪八戒”
“3 沙僧”

量 问题 = 行一("名字"、"追求"、"喜爱颜色")
量 答案 = 行一("玄奘"、"真经"、空)

解对问题与(答案)里的(问物、回复)， “对何<另项>皆有事 「与」(另：可迭<另项>：可迭<元二<项、另项>>)”
  说("你的${问物}是什么？答曰，${回复}")

对零止10步长2里的，说(它)。 

“with open(file) as f: f.close()”
尝试文件(径)去开启()成书，书去写文("emmm")。
接迎打开失败不常，告警("emmmmm: $径")。
“终焉，书去关闭()。”

对何<项> 项：有序<项> 皆有
事 冒泡排序(动片：动切片<项>) 为
  对动片的索引里的『某针』，
    对(某针后..动片的末引)里的『此试』，
      若动片[此试]小动片[某针]，动片去交换(此试、某针)。
对何<项>皆有
扩物 动切片<项> 为
  事 交换(甲：引数、乙：引数) 为
    我[甲] = 我[乙]；我[乙] = 老甲
  其中，
    量 老甲 = 我[甲]

例 『某易语言而不是易飞扬程序』: 应用程序() “还有『带参应用程序』” 为
  实现的事 入口() 为
    量 a = 听去数一()
    量 b = 听去数一()
    若a大b，交换(a、b)。“假设这是1.0，绝句有存储抽象”
    a定「不大b」
    说("$a $b") “绝句可没有啥『调试说』”
    回效果 “当然是不必显式写出来的”

事 说妖精(妖精：文、原型：文、能耐：文、降服者：文) 为
  说("尽管善于${能耐}，${妖精名}仍被${降服者}制服，变回${原型}")
例 西游记: 应用程序() 为
  实现的事 入口() = 说妖精("白骨精"、"白骨"、能耐="变化"、降服者="孙悟空")
“绝句暂时不打算支持 partial application”
量 说白骨精：(文)效果 = 函数，〖能耐〗说妖精("白骨精"、"白骨"、能耐、降服者="孙悟空")。

“看来设计类型推导方法是个苦差事啊，学术派一点要用 unification 归一化，而且逻辑式 miniKanren 好像不也是用 unification state&goals？
看来多态推导有点麻烦…… 大概还是写的出吧。”

量『a』=1；晚成的变参『s』：文 “提议：显式类型变参简写时不能加修饰符”

引记法 绝句.额联 「令为」
引记法 绝句.符号 「以」
引记法 绝句.符号 「~个」
引记法 绝句.符号 「化」

引 Apache.PortableRuntime

例 随机生成: App 为“皮一下，标准库里不一定有这个别名，当然绝句也可以用上「类物别名」的”
  实现的事 入口() 为
    说("请输入将要生成的随机数个数:")
    量 数目 = 听去数一()
    说("下面开始生成${数目}个随机数====>")
    随机数之集去取(数目个) 令为，它以(" ")去接并()。令为(::说)
    说("<========随机数已生成")
    听去行一() “暂停屏幕滚动用”

例 随机数之集：随机数集()
物 随机数集 为 “也可以是单例的”
  私下、晚成的“lateinit”变参 存池：内存池
  事 取(次：数目)：行<数> 为
    存池 = 内存池()
    量 随机行：行<数> = 行一()
    解对 次里的_，随机行去加入(随便一数())。
    回随机行     
  私下的事 随便一数()：数
  = 随机数器去生成随机数(1、分配器=存池)
  去化数()

“标准库定义”
【只可内联】内联的事 说(话：文) 为
  说一点(话)；说完了()

说点("你")；说点("好")；说完了()
控制台去说("你好")
引记法 绝句.符号 「写」
引 控制台.标准输出 “just a joke”
标准输出写"你好"

若此人之为男，说("👻")、说("👻")。 
“（哦，想起来了，此人.为男也不失为一种编程风格，但我现在对不使用引记法的绝句代码表示怀疑。）” “此人的之为男”
量P=元二(0、0)
属别名 路径 = 文
待例的事 打开文件(模式：打开模式、文件名：路径)：文件
量 hello = 打开文件(打开模式.只读、"hello.txt")

定记法 「模式」
扩物 文 为
  事「模式」(模式：打开模式)：元二<路径、打开模式> = 元二(我、模式)
待例的事 打开文件(目标：元二<路径、打开模式>)：文件
量 hello = 打开文件("hello.txt" 模式 打开模式.只读)

引全 打开模式 “import OpenMode.*”
例物 打开模式 为
  只读、只写、读写
打开文件("hello.txt"模式只读)
量 用户配置文件 = 打开文件(只读、"hello.txt")
量 用户配置文件 = 打开文件(只读、"hello.txt") 
量 用户配置文件 = 尝试，打开文件(只读、"hello.txt") 。
  接迎 打开失败成误，误去输出()、回。

变数 i=0；重复若i小10，i = i后。“i=10” 

变数 i=0；重复，i = i后。若假。 “i=1” 
变数 i=0；重复若假，i = i后。 “i=0” 

事『翻倍』(甲：数)：数 = 甲*2 “跟括号式的名字后不用加空格”
“或者，”
事 翻倍(甲：数)：数 为
  量乙 = 甲*2；回乙 “知道我为什么用「量」而且区分了「量」和变参吧？存储和「临时值」实际上有不同的”
“或者，”
事『翻倍』(甲：数)：数 = 甲去乘(二)令为，〖乙〗回[令为]乙。

对何<项>皆有
【只可内联】的事 行一(变长的 项目：项)：行<项> 为 “Kotlin listOf(…)”
  量 此行：行<项> = 行()
  对项目里的，此行去加(它)。回此行
对[楼] 此楼里的家，对家里的这人，
  若这人的包里有枪，去报告(警察、这人)、略过[楼]。
“绝句里有「」表示中缀、『』表示名字、{} 是可选的逗号表示法替换（为了语言一致性，我也不想让那些程序员写东西有时「为」有时 「{}」……）”

宫水家去找，〖她〗她的名字是"三叶"。手机上的最近聊天记录去数，它的发送者是泷。有若「大五十」 空则，沃日。

引记法 绝句.符号 「止」

“始末是 right-inclusive、起止是 right-exclusive，注意『起止』不能在不加方括的情况下作为名字”
事 埃氏篩(末：数)：行<数> 为
  量 此为素 = 动组(长=末)，真。
  量『末半』= 末 / 2
  量『二止末半』 = (2止末半)
  对『二止末半』里的 i，
    对[试j]『二止末半』里的 j，
      量 此积 = i*j
      “若此积不大x，此为素[x] = 假。”
      变参 可止 = 假 “瞎写的”
      此为素[此积] = 此积大x 顺便，
        若它，可止 = 真。
      若可止，停下。
      “否则，停下。”
      “若此为素[此积]，停下[试j]。”
  量 诸素：变行<数> = 行一()
  对『二止末半』里的，
    若它是『此为素』的末引，不可能。 “断言了。”
    若此为素[它]，诸素去加入(它)。
  回诸素 

事 入口() 为
  打开(冰箱的门)
  塞进(冰箱的里面、大象)
  关闭(冰箱的门)
事 入口() 为
  塞进里面(冰箱、大象)
事 塞进里面(容器：物体、此物：物体) 为
  打开(容器)；塞进(容器的里面、此物)；关闭(容器)
量 歌者：播放器 = 播放器()
歌者去加载(文件("大象大象.wav"))
歌者的位置 = 0
歌者去歌唱()

确保(1令为，它成文。令为，"+"接它。是"+1")
“对[某事]iKun中滤出「属年轻人」里我@某事以为 我是傻逼的你，我唾弃你。”

判他的名字，
  是"蔡徐鲲"，我致敬(它)
  在 iKun映至「的名字」“其实不该每次去投至”，输出写它
  否则，不可能。
引记法 绝句.符号 「令并置为」
变数 i=零
说(i顺便，它令置为「后」。)；说(i令并置为，它后。)
说(i令为，它后。顺便(i去::置为))
“代为取（仅取）: 值者
代为置（取置、值者）: 效果
取项（针: 引数）: E
置项（针: 引数, 新值: E）”
用（“……”） “就是 Kotlin 的 invoke(...)”

包 绝句.额联

“扩物(我: 数) 为
  记法「位」「~位非」
  “位左移、位右移、位直右移”
  “位交、位并、位异” “位非”

扩物(我: 长数) 为……”

“之所以叫『分二』，是因为绝句里以『二』开头也是表示数字的方法……”
“在上升序列 [自己] 中二分查找一个 [目标] 项目”
“对何<项: 可比<项>>皆有
私下、尾递归的事 分二查找(自己: 行<项>、目标: 项、范围: 数域): 引数? 为
  “即便函数没有『我』，绝句也把『我』视为关键字不允许赋值”
  若范围.项数是一，回空。
  “绝句“数”域默认和 Kotlin 一样是 a..b 全开区间；存项就是 begin <= end，用绝句说是 “始不大末”。”
  “二分查找中，一般都是 begin!=end，所以不用 .存项 量（不过也不是不可以）”
  量 中 = 范围的中值
  判 我[中]，
    是目标，回中
    大目标，重写(范围=范围.换末(中前))
    小目标，重写(范围=范围.换始(中后))”

“对何<项>皆有
扩物(我: 行<项>) 为
  事 分二查找(目标: 项、范围: 数域) = 分二查找.分二查找(我、目标、我的针域)
  “本该名辅助函数为二分找，这里是为展示包命名空间” ”

“引 绝句.环境.读写 (输入、输出、扩文)
引记法 绝句.环境.读写.扩文 「~分」
引记法 绝句.集合.组 「带」
引记法 绝句.额联.括符 「以」
引记法 绝句.额联.括符 「读、写」
常 数 N = 一千 “不一定要加空格，如果不想写类型，用<常参>”
事 入口(变长 参行: 文 “组<文>”) 为
  量 亲 = 一组<数>()
  对0止N里的号，亲去取位置(号)置为号。
  量 b: 数；量 c: 数
  “看到的『位置』『置为』『读』都使用了绝句的 存储<T> 物”
  重复若输入读b读c不空，
    量 a = 亲[b]
    若亲[c]是a，略过。
    对亲带存储里的d亲、d亲值，若d亲是c，
      d亲值置为a “d亲值 = a”
    输出以' '分 写b写c ”

例物 喜爱程度 为
  喜爱、很喜爱、非常喜爱、爱到爆炸 “emmm...”
公开的 “其实默认就是公开” 事 夸夸群() 为
  晚成的量 话: 文
  对用户里属人的你，话 置为判 我.度爱(你)，
    喜爱，"爱你！"
    很喜爱，"永远给你${名字}打 call"
    非常喜爱，"我不要你以为，我只要我以为"
    爱到爆炸，"你的爸爸大中国"
    以上情况皆，话令置为，它接"耶！"。 “只是个例子” 
    否则，说("emmm")、回。 “该填『不可能』”
  说(话) 
用户里滤出，它存于穷逼VIP里的。全都让(本群去::踢了)；
对用户里滤出「存于穷逼VIP里的」，本群.踢了(它)。

//!语者 无例之物
//!语者 此即存储
对何<值者>皆有
密封的内联物 无常 为
  私下的内联物 断止: 无常<*>()
  私下的内联物 决常(量 你: 值者): 无常<值者>() 为
    算符的事 此即值() = 你
  “大致是这样吧，注意这是编译器的 intrinsics”
比如说，假设有 事 读一行(): 无常<文>

尝试，
  量 输入行 取者，读一行()。 “内联类没有『我』分配，无法作为通常值存储”
  “或者，你也可以写 量 输入行 = 读一行()作决常”
  输出 写 输入行 “编译器知道『输入行』的「推帧单位」和赋值语句的是一个，且这一句能执行必定代表无异常发生，智能转型。”
接迎 文件结束不常成『异事』，异事去写出()。 “『标识符』是绝句的一种文法”
  “当然关键字<接迎>后不加空格也可以”
终焉，
  “这只是个例子”

引记法 绝句.区间.数域 「投」
引记法 绝句.区间.数域 「换」
对何<项>皆有
扩物(我: 行<项>) 为
  私下、尾递归的事 二分查找(你: 项、区: 数域): 引数? 为
    量 中针 = 区的中值
    判我[中针]，
      是你，回中针
      大你，重写(区=区投末，中针前。) “逗号文法 确保（一行(1、2、3).全是，它 不小 一。）”
      “二分查找(你, 区.mapBegin { 中针.dec() })”
      小你，重写(区=区换始(中针))
    “编译器知道没有其他情况”
    
“对所有编程语言里语言是中文的，若它属辣鸡设计，
  锤爆(它)”
  
“绝句词法：认为换行是 [\n\r] 里任意一个，数行数的时候按 (\n?!<=\r|\r\n) 来数（也就是说，支持 Mac 和 Linux 式的 LF/CRLF 换行
文件开头可以是 ^#!.*$, 这一行会被跳过
空格：[ \t\n\r\u{0x3000}] — 全角空格
注释：
  “” 可嵌套的『引号』注释

可选的缩进文法（就是「为……」和「，……」文法）里会预先取缩进长度，在这种文法中空格更加受到重视。

整数值：
  '-'? … 'L'?
  默认『数(Int)』，后缀 'L' 以默认『长数(Long)』，下划线不得连续出现
  除非就是"0"，数值部分不得以 '0' 开头
  当有负号时，数值部分不应为 0, 否则编译器要提示
普通记法：[_0-9]+
十六进记法：'0x' [_0-9A-Fa-f]+
二进制记法：'0b' [_0-1]+
汉字记法单位：十百千万亿，数字：一二三四五六七八九
浮点数值：
  '-'? …frac 'F'?
  frac = '.' digits
  默认『实数(Double)』，后缀 'F' 以默认『浮数(Float)』，下划线不得连续出现
普通记法：digits frac?
Exponent记法：digits frac? [Ee] '-'? digits

字符：支持转义的一个字符
转义：
  '\' [tbnr\"$']
  '\u' hexDigit*4

字符串：
  char term = (anychar) ~('\'|term) / escape
  常量字符串： '"' char('"')* '"'
  内联字符串：'"' (char('"') ~'$'|'$' Name | '${'Expr'}')* '"'
  长段文法：~~缩进块~~ """ Name 为 
名字：任何Kotlin里有效的标识符
  '『' (anychar)+ '』'
真假：'真'/'假' 
空：'空' 
”
“(小某阶的表示)*某阶单位+(小某阶一位的表示)?
(小某阶的表示)*某阶单位+零(小某阶的表示)?

「一千」的前面是小于千的（无单位）
「五十千」的前面是小于千的（十）”
