# 谈点算符中缀链的实现法

憋几月没写文了。恰逢要做 emmet 的便利复刻版，就从 (1+2*3) 这种表达式的解析谈起吧。

对 (+) (*) 这类东西有人叫运算符也有人叫中缀计算，咱管叫操作符，因为 "c"+"ao" 在数学里好像不叫计算？而 `::std` 的这种 `::` `<>` 类符号，则应该叫 marker ，标记。

不可能哒！想要搞定这个问题？首先从「完整」的字符串谈起吧，毕竟得先熟悉问题的最小模型，设计虽小俱全的基础对象和测试输入 才能真正开始；当然，这次不会提正则表达式。别怕，我只会心疼小白！

有耐心看到最后的，赏你做 irb, py 式 REPL 交互执行命令行的能力，不带高亮补齐、带空白注释、括号不配对可输多行。 


我们都知道，字符串相当于字符的列表，串表的本质都是可随机访问序列——意味着有 n, s[i] 两个符号，分别意味序列长度和第 i 项，通过 for(i=0;i<n;i++)op(s[i]) 来用 op(char) 子程序遍历此串。

当然，这次还得用 "abc".slice(1,3)=="bc" 这个操作(符号)，注意索引 3==n ，其在 "c" 之后，s[3] 即 s[n] 代表无值的末尾。

一般人只会用大小写变形、搜索/替换;切分/拼合 的操作，例如 s.indexOf("f**k")==-1 代表无此脏词、capitalize=(s)=>s[0].toUpperCase()+s.slice(1) 首字大写 it("badGuy")==("B"+"adGuy") ，仅这种程度的思考？想看完你要做好水深的准备。

如果你足够熟悉编程，组织序列索引就像操纵食指一样自如；复习一下：

+ （以0为起始的）索引 i 与 常数d ，(d+i) 只需举 i=0,d=1 的情况即易理解偏移量的叠加
+ 编程常用左开右闭区间即 for(i=0;i<n;i++){} 里 i 存于 `0..<n` ；这种区间 1..<5 长4 而 0..<5 长5 ，易与数组 (a[i]) 长度、索引集始末对照
+ substr(i,n) 和 slice(i0,i1) 在 i0=0 或 i1=n=s.length 的情况是等效的，i1,i0就类似n,skipN。如果索引查询和计算频繁 slice 更不易错
+ a[i] 索引也被称为 get 或下标操作，因为数学数组通过下标数字来指代元素
+ 不要害羞，用手指着屏幕上的 "abc" 提示自己索引号(i=?)和算法思路/单个表达式写法不丢人


先看看 CSS 选择器单项的写法， tag.class#id ，请实现 readEmet("div.art#main") == {tag:"div",className:"art",id:"main"} 的字符串输入-解析器。

易见此程序有： markers=".#", i=0, res={} 三变量，想构造 res[k]=v 结果必知此处 k 基于 .# 取，输入可视为 .# 前/后缀了的子串的拼合，故二层循环里首要的计算应该是 s.indexOf(sMark, i) ；拓展思路，如果去掉 3变量子程序 s.indexOf(substr, i0) 的搜索起始 i0 ， "div#main.mark" 应该也是有效输入；"#a#b" 可能被视为 #"a#b"。（略 省略 i0 对区间迭代 for indexOf 法是错误的 且此法不能混序）

markers 属既定内部数据，信息量至少够完成返回对象，应定为 {"":"tag", ".":"className",  "#":"id"}
程序控制流的框架（略 这里是 zipWithNext-caller）属编程经验，提示：

```py
for(sMark in markers):
  i=s.indexOf(sMark,i); if i==-1: continue
  onMark(sMark,i)
onMark("$", s.length)
return res
```

请看 "a.b#c" ，可视为 a .b #c 或 a. b# c 帮助理解；需要 .# 来确定 o[k]=v 的 k 故选择视为前缀切分(其1)，但在 indexOf 时我们只知道 .b 的位置不知道 "b" 即 v 的 长度/结束位置（应取至 #c 或者输入的末尾），不难发现：循环里 v=s.slice(i, i1) 的信息完全时 i 其实指代上一个标号的 末端(i+sMark.length)的位置而 v 也其实代表上一轮 .# 的值。
注意！初始i=0，而在输入末端还有一次 o[k]=v 的 k,v 值没有消耗，故强制在结尾用特例参数"$"再来一轮。（值的被用性属编程经验，基此可以推测程序正确写法）

故在 readEmet 新建局部变量 iK1, vK1 (k 即 .# ，此即需保留 k 即 sMark 或 marker[k] 即 v 如 "id")，onMark 里关键代码 res[vK1]=s.slice(iK1,i); iK1=(i+k.length);vK1=markers[k] 交换回合的 v 索引区间的锚点。

现在发现 "":"tag" 无效了吧？逐步修正，这就是算法设计。 if(vK1==null) 来设置第一个 res[k] 吧。

刚刚，咱已经实现了一个“简单”但足够强大的解析器，不信你参数化 markers 列表，它能轻易解析 "a年b月c日"、"a省b市c区" 这些输入。（略 虽然因为顺序是 .value ，变量名要左移一位 输入还不能省略任一位 呃）

"a b".split(" ") 算不算解析？是！因为它把 "a b" 变成了 [s(0,1), s(2,3)] (其中 s="a b".slice)；解析的本质类似将线性的 s[i] 序列与结构化数据构造出对应关系，能实现高大上应用的技术仅此而已。

```js
split=function*(s,sep){ var i=0, iGot;
  while((iGot=s.indexOf(sep,i))!=-1) {
    yield s.slice(i,iGot); i=iGot+sep.length;
  }; yield s.slice(i)
}
```

你已经理解了民科瞎 JB 可能捣鼓出的，也是本次程序算法上你所需级别的天花板。那么，为什么解析器要吃流？为什么不能只用 Iterator ？
傻瓜式的说法是，这次我们要支持可能单/多行输入的 REPL ，决不能仅是 while((ln=gets(">"))!=EOF){print(eval(ln))}  的读单行-执行 循环，咱需要字符级的输入精度，判断是执行还是读下一行。

设想下身份证号11位，如果出身日期如 2002/01/30 里月份不需要首零呢？普通人肯定想判 length 再重算自己要提取信息的 slice ，其实这就相当于 s[4] 即"2/0" 末是可省略的 s[i] 位置，虽然这在解析中不常见，它有点像流所能为求得函数的“构造”函数 提供的复用性了。

对第一个问号，请看 "a b; e f" ，假设我们的目的是拆出一个 table 即二维数组。（略 例如一个“风趣”的随机界面文本 gettext(k) 就会用到 [["你好","别来无恙"], ] 这种结构，第一层是文本编号第二层是随机选项集）

你仍可以 it.split(";").map(s=>s.split(" ")) ，或者说 split2D=(s,sep,sep1)=>s.split(sep).map(ss=>ss.split(sep1)), res=split2D("a b", ";"," ") 轻松解决问题。

可是，如果我提一个简单的要求——第二层可能包含不处理的 "\;" 会怎样？此法实际把字符串两层独立扫描了两遍，整体 split() 时一遍，map ss.split() 时 res[i] 维整体各自共扫一遍，如果你乐意写 split3D ，那 (s[i]) 的操作数不可避免的是 O(3n) ，哪怕我只是支持 "a b ; c " 的 s.trim().split() 都会造成一定量重复遍历。

当然性能问题其次，重要的是这么做难完成刚刚我的要求——如果要求 " "切分维(即 res[i][j] 维)  末项可以含分号（属需预读";"计数的情况），即便修改 split() 去支持 \; 也是徒劳的，因为";"的语义实际上是由第二维的 split() 在第一维 split() 执行中共同决定！即便实现也不得利用子程序，大量代码将重复。

这种情况不常见？在 JSON 里经常出现！例如 ["Hello, world", "yup"] 显而易见是有效的；对「字符歧义 上下文」的处置 是文本处理编程者的分水岭，也是算法、学院与技巧派的分界线。

针对上面逗号的语义冲突，一些人抛弃了利用子程序构造结果的方法（如刚刚的 split2D 与其 [[],]）而求助于手写栈(FIFO, first-in-out)和状态机的“自由发挥”。

的确，如果你熟悉算法这并不困难，两个扫描算法片段与 split() 能轻易共享当前读取位置；不过从来开始汇编CPU指令就是最自由的，太死板冗长啊！

不能共享 "" 字串这种基础规则，但它外围的许多东西也有使用。为了跳空格和“分用途解析”人们撕裂出分词器与解析器，撂下大量重复的规则；为了解决「状态机难写」人们设计了 scanner,parser 的 code generator ，还美其名曰 compiler compiler ，根本就是搞错了重点：线性序列解析至结构数据的流程，反复出现在各种应用里，并非语言工具的专利；而编译器、解释器至关重要的是分析变换并非一个 parse 操作，舍本逐末的结果就是难学，极少人能做新的自动生成，越来越多的人在写重复难看的代码。

你只是还不知道确实有别的方法能组织出这种 [[],] 数据模式，对『输入数据 stream 』和『子程序 combinator 』的缺乏了解限制了可能性。这个必须被共享的信息是扫描的当前位置 i 而最小接口是 s[i], s.move(d) ，这就构成了流。

有了流就有了取输入前缀、得消耗长度的解析子程序，这样不同层级区间在调用栈上已有区分，字符的语义不会冲突。这叫『递归下降法』

比如 s.takeWhile{it.isDigit()} 能轻易从流中取数字前缀，当然流式输入的本质除了暴露等待用户击键序列的真“流”，就是共享当前位置 i 而已了，暴露 i 能方便 indexOf 等既有方法的利用。

那么第二个问号，为什么 Iterator(即 next 函数值) 不够呢？
刚才的 takeWhile ，试想其前还有另一个 takeWhile =="_" 看看执行顺序会怎么样？例 "__123" 等 next() 到 1 时它才知道 "_" 没有了，但 1 也已经回不来了，第二次只能拿到 "23" ，所以输入流是带判断的，必须方便界定所有权，和 foreach 的迭代器流不是同一类。（略 一些流可以自由 seek 或 mark/reset 但解析器其实完全没必要）

除了让所有（本质是用于模式匹配并组织结果的）解析子程序都接受存有可变量的流对象作参数，还可以选择让它们返回吃剩的输入字串尾，这样单输入-2输出的法子有“拆分”的理论优雅性。纯函数式会用这法子，但它既低效又不实用也不易理解，保持返回值纯洁而滑移流对象的做法较易学。

有时候天才傻瓜真就只有一线之隔，天才未必天生才行。

函数也是有趣的。会编程的人懂得用带变量的子程序闭包构筑和谐的系统，毕竟对象的本质就是能访问局部变量的闭包，如果你有 function plus(a,b) {}，变形 plus=a=>b=>{} 就能制造 add1=plus(1) 这种能干特殊化任务的函数了。另一个有趣点是 pipe=(op,op1)=>x=>op1(op(x)), add2=pipe(add1,add1) ，函数可被其它函数修饰，其结果也能再修饰；通过这种方法能以极简的表达式实现极牛的效果，这叫『组合子』

其实前面教的“解析子程序输入”，总之就是传 substr ，或者通过传递可变对象共享 i 变量，但接下来我们会在“词条”级，已切分的文本上学习 (1+2*3) 中缀优先级的两种解析算法，以及负号、括号、 .name 号的解析技巧。

解析就是对输入里划分出未知长的子序列，应用变换、存入输出的临时结构。流状态和程序与调用栈，重复、嵌套、分支的序列模式与子程序时序结构在此交融；第一者称为分词，后者统称解析。

## 方法一 链上锚点递归

```js
fun stream(s) {var i=0,n=s.length; return (d)=>{
  let slice=(i0,i1,ld)=>(ld==1)? s[i0] : s.slice(i0,i1);
  if(d<0){let i0=i; i+=(-d); return slice(i0,i,-d)}
  else return i<n? slice(i,i+d,d) : null;
}}
const toks=s=>stream(s.split(" "));
```

于是 s=toks("a b c"); s(1)+s(-1)=="a"+"a"; s(2)==["b","c"] ，问题基本模型建立。

如何知道 1+2*3 式中缀链何时结末？不难发现 *3 后没有新个算符，这就足够。

要令 1+2*3==1+(2*3) ，算符 +* 必须有『优先级』的概念。比如其分别是 2,1 而因 1<2 ， + 号的右参数会被 * 给“抢”过去(小者先、小者优先级大)。

现在我们叫这个尚不知特点的解析程序 readOps ，简称 it ，不难发现 it("1") 和 it("1 + 2") 在结末时都没有组织新项而本质相同，故+参数 base:Atom (原子表达式 也即简单表达式)

因为 Atom +-/* Atom 后仍是 Atom ，才可能组织出计算，才有算符链和优先级的问题。

锚点法的关键在于提供序列上相邻两点的信息，它必须新建 old (即 last) 变量，而 +(*) 的重组显然需要 +* 相比较后立即套上执行顺序，所以+参数 op_left: Op

然后我们需要解析 "123" 的以及 "+" 等中缀的俩解析器，以及它们的输入流 s ，故完整参数如下：

type Op={id,prec,join}
readOps=(pOp,pAtom)=>(s,base:Atom=read,op_left:Op=null)=>{}

Op.id 不是必须，因为两级解析器其实只用交流 op 运算符的 prec 优先级、join (a,b)=> 结果归纳 就够了。

下面 (a?:b) 代表“如果 a 为空则做 b”；不难发现读链头时我们要先判断是不是真有 "1+" 的算符在后部，不然重组顺序的 op_left 子程序就没调用的意义。

```kotlin
read(s)=pAtom().let:
  read(s, it, pOp()?:return it)
read(s,base,opL):
  opR = pOp() ?: return base
  rhs = pAtom() ?: error("1+ ?")
  assocL() = read(s,opL.join(base, rhs),opR)
  assocR() = opL.join(base, read(s,rhs,opR))
  return when opL:
    <opR: assocL()
    >opR: assocR()
    ==opR: if(op.isRAssoc) assocR() else assocL()
```

当然，算符有右结合问题（1**2**3 里先算 2,3），比 isRAssoc 更优雅的方法是同时指定 prec L/R ，这样在大 when 里面直接按左右取其 prec 相较即可。

## 方法二 嵌套深度组表

复用方法一的 stream 和 Op 模型，锚点法把 (1+2+3*4) 变成 (1+2)+(3*4) 而组表法把它变成 (+ 1 2 (* 3 4)) ，理论上存储性能更优而且更利于编译优化，并且也是同时支持 前/后缀 算符优先级的算法。

算法的思路非常简单，读 (1+2*3+4) 里的 + 时它会一起读出同算符的列表 [1,]，到 * 时比较 +* ，小即递归下去、添加结果(点1)，* 里大即(上 *+ 4) 得出结果 (* 2 3) 让上级继续解析。

其只需 op_left 参数判断是递归还是回溯给上级，参数初始是 prec=0 而算法仅需 Op{id,prec} ，即语义接口与 join 法不同；此法的类左递归 chainl/r 变体是函数式解析的惯用法；要支持前/后缀算符(如 - !) 只需在锚点循环前/后添加 取其优先级-重调用 逻辑。

点1 相当前法的 assocR() ，而此法的 assocL() 实际是在线性的 List 数据里储存，从语法数据结构上效能更优。

本质上都是二相较的锚点法，但是它将二者比较后收为“同层级”列表，而不是立刻 op.join 施用语义。比 readOps 的 read 少一个 base:Atom 而多一个 var res: List<Atom>

## 修饰原子表达式 左递归链
ab aab->报警

## 函数与闭包、动态与词法作用域

请看 [这篇代码生成随写](cg_essay.md)

## 立即、惰性与每次求值、闭包

据说 C 时代就开始有“计算机科学家”争论这个选择了，应该说传名(by-name) 或许能节约计算量，而传值(int,void* 等)对『子程序』这个名字更协调，比如 istream.read(new byte[4]) ，如果咱通过某种改写顺便拿到此数组的引用，传名的话看起来有些奇怪，而且 C 没有传名必要的闭包支持。

术语是 call-by- value/need/name ，其3 也即 by-expr ，传表达式调用。

知道 && 和 & 有什么区别吗？一些人说 (0b1&&0b0) 是无效的、(p&q) 里参数只能是 int，其实并不！二者的区别在于“短路性”—— (a&&b) 里 b 可能是不计算的，而 (a&b) 是完整计算的；许多语言如 Kotlin 已经禁用了这种不该由程序员判断的区别。

如果你写过 bash ，会发现很多人用 [ test ] && a 取代 if ， [ test ] || b 取代 if not
而 if(a&&b) 也就相当于 if(a)if(b) 、if(a||b) 大致是 if(a);if(!a&&b) 当然别学脚本者写 a||b() ，惰性的计算有时被用作 if ，这在一定程度和『调用策略』相关

略：如果你喜欢 js ，会经常看到 a=a||b(); 这种表达式，有时被称为“保护初始化”，能避免冲突和支持热补丁重载，但 a 可能是 0,false 时不能用。

在 C 语言初期时就有人争论是该在 调用方(caller) 计算参数还是由 被调方(callee) 计算，看起来不可理喻——被调方怎么可能拥有调用方可见的所有信息？

C 最后是用了前者，传值(即传结果)调用，但后者，传名调用，在函数式 闭包(closure) 的支持下也是可能的。退一万步说，C 预处理宏也是一种“传名调用”呢，只不过缺乏作用域，变量集的便利性。

闭包是程序与其必要变量的融合；对应到子程序语法上的嵌套关系，就是『词法作用域(lexical scoping)』，支持它的语言可以让一段小代码片段带着它包住的『外部函数』的外部变量(即 upvalue) 在任意地方执行、求值，无论其外部函数是否正在执行，当然也能实现传名调用与 by-need 的仅首次求值。

## 控制流的铺平、跳转目标的回填

我们常用 if, for, while 控制结构，下为对应汇编模式

```plain
if(p){a;} b;
if(p)a; else {b;} c;

br.not @end; a; @end: b;
br.not @else; a; jmp @end; @else: b; @end: c;

for(i=0;i<n;i+=1) op()
```
