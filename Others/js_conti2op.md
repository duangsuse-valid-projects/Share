# JS Generator 随谈

闭包 `a=> (()=>a)` 是能封住外围量(upvalue) 的特性，用这种方法组成各种任务也非常符合面向对象的对象图、自动垃圾回收思想。

序列生成器 `function* f(){yield 1;yield*[2]}` 是能让 f 保存状态并提交值的特性，相当于收集到 `[].push(x)` ，非常灵活。

二者看起来毫无关系，当然一个是数据侧一个是流控制侧，尽管修改单位都是函数也联系不大，我是谈点别的。

如果说有什么是无生成器不能实现的，大概是 `async` ，因为你没法 `let r=yield fetch();` 这样灵活的转交执行权，化主动为被动。

我一直不知道为什么 Kotlin 和 Lua 的 协程 coroutine 就不能提供这样符合应用思想的 API ，为什么协程需要 Dispatcher ， `delay` 还可以要线程池去支持，以及 Kt 的 Sequence 和其 Coroutine 到底是啥关系

你看大名鼎鼎 `co()`.js 实现的 async 多直白，就是把 `yield promised()` 的挂起函数再 `lastPromise.then(op.then)` 复苏成 `yield` 表达式的值就完了，你看这像不像 UNIX 的 `if(fork()==pidChlid)` 函数，新进程直接在代码的 `fork()` 后位置执行，像 `set/long jmp()` ，灵活结合了 runner 的上下文，一点也不魔法但显得语言结构越来越像数据了。

如果没有生成器怎么办？异步只能是被动、被以结果调用，靠 `Promise.then` 组成链条也还算挺函数式，`then` 的自动铺平与 `catch` 能力也不造成回调地狱还有 `Promise.all/race` 组合方法，可终究是做不到直接调用就能拿结果（的主动请求）

我可以把序列做成回调的形式： `[1,2,3].forEach(op)`，或者说 `seq(1,2,3, console.log); seq=(...a)=>a.pop()(a)` 利用不定长参和数组右改写操作 `pop` 提供接口来取代 `yield` ，好像它反而更简洁啊，这种序列可以等价 `function*` 生成器吗？

## 可不可以

小白一点的可能直接就觉得不行了，那我先想 `(op=(a1,onEach)=>{})=> (a1)=>function*(){ op(a1, x=>{yield x}) }` 行不行？

你可以试试，`yield` 的函数不是 `fun*` 当然语法错误，如果它是？不用说你也知道， `onEach` 是不预期任何返回值的，而 `fun*` 的返回值是挂起状态、能以 `yield/it.next(v)` 交互的协程对象，外层 `fun*` 直接裂开，一项也不生成出。

那么它可不可以提供作 `Iterator` API(就是 `next={value,done}` 函数) 呢？也不行，除非先用 onEach 收集到 `a=[]` 再 `a.values()` ，没法求一次得一项，因为，__接受回调的你无法被休眠__。


问问自己为什么要 iter 的 API ？可能是因为你想写 forEach 不想直接弄回调、可能是因为你想在某一项停止不必要的计算(`takeWhile` 和 `find` 这种)，显然利用回调你操纵不了那函数的那次调用，真被动。

题外话，你可以 `(op,...a)=>{let r=[];op(...a,r.push);return r}` 这样自动收集 `onEach` 到的结果，或者把前面再做成 `(op)=>(...a)=>` 这样 `(it(op)) (args)==[]` 包下直接变返 Array 的版本，编程入魔了就是各种返回值、回调函参、调回调参数都能瞎组合的有病……

## JS 的差别

无论什么语言往往都有不同的运行时，比如 VB 有 wscript 和 VBA， js 也有浏览器和 libev nodejs 的区别，二者差别除了 C 系 API 就是 node 更加异步甚至略偏执…… 多线程上脚本语言都不会太重视，但我相信只有读写可能冲突才会存在线程问题。

对于没法 `sleep(t_ms)` 的浏览器环境而言，`setTimeout` 类定时器函数是唯一的办法，当然我觉得这很好（很难相信 vscode 是单js线程的应用程序）

Kt `repeat(10) { i->launch { delay(1000*(10-i)); print("$i ") } }` 可以创建一大堆休眠(wait on `delay`)协程在 10s 从 0 数到 10 ，这里函数本身仿佛也变成了异步任务

dispatcher 负责的就是 闭包+协程 了的函数对象分派到(一堆等待队列里有新任务的 线程?)的执行，当然它也可以在某刻 `setDelay` 再去 execute 任务

其实如果不是 Android 的平台习惯的过度设计，Kt CLI 方面也和 DOM 类似，没有执行资源、池的区别问题，全局一个也够。

Scope 应该是 Kt 自己的特性了，涉及到 `yield()`, `Future.await()` 等利用 Intrinsic 函数的归属协程问题，比如 runBlocking 里在等的是哪个协程的  return 、yield 的是要挂起哪层协程，我没太看

## `AsyncGenerator`

`co` 执行器利用可挂起程序实现了 await/async (的第1) ，可它要让父层帮忙转交自己给异步调用(不存在“等待”呦) 就已经占用了 `fun*` 的交互了，如果我每生成一项都要 await 一个，一个协程够不够？

（虽然这是 ES2017 的 cutting-edge 特性，但只需父层帮忙判个类型就成，就是脑筋急转弯而已

那么现在除了 yield 又可以 await 甚至 `yield await` 了，但别忘了本质上还是先 await 再把 await 的结果给 yield ，两个不同的操作通过相同的 `v=(yield r) / next(gen)==r;gen.next(v)` 交互，对 `co` 言就是继续 `while` 还是 `yield` 一次的判定这样，而父层 `co()` 现在必须从单 return 的 `fun` 变成 `fun*` 这样，因为它要照映被执行层 yield 的语义。

不要忘了 Kt 里 yield/await 都只是方法动词而已，不是“语言内部”的关键字。

## 题外话

其实仅靠闭包，语言的元编程灵活性、表现力也都是杠杠的，尽管主被动有区别（调用栈上 ~~谁是top谁被~~）惰性计算用回调参+异常真做的到。

协程、闭包、异常是现代编程语言标志特性， C 语言最多能实现异常，毕竟它是结构化编程不是面向(函数)对象的，而 C++ 全部支持（一个连亲爸都只懂 60% 的可怜娃）。

协程实质上不依赖闭包而实现，闭包的特征是词法作用域，也就是函数的内层函数能读写这层的变量，而协程相当于对调用栈本层指令指针(术语 ip,pc)的保持；即便不允许词域，最小保留这层栈变量的协程休眠操作也是够的

其实 generator 本身已经是二者的融合了（语言都是特性织起来的），如果 js 支持对称协程(启动方的名字也不能在 yield 隐含，resume 时都得显式给出)…… 也不可能，只有1个栈帧能是活跃的，切换必意味着撤下、存好。

总而言之，程序和数据，这二者是紧密纠缠的，很难单独去提升其中一个；不然就容易过于执着于代码字面结构、或拓展灵活性过低。

别忘了老冯的计算机模型：带存储、控制、IO 的计算器！一个都不能少！
