BPU BinStruct 读写器 支持 Pool,Union 常量池/并存体，也通过 Bkfill 回填地址不定的项目如 ELF节，以此得名BPU

bp=BPU(file/buf/sz) 可用打开读写流， obj=bin_pat(bp) 执行读取， pat(obj, 默认 b=BPU(sz=pat(obj,NO))) 写入和计算大小

bp 就只是有 p=0, isLE=1 位置和大小端属性的Blob对象，至少能单数值读写

Struct(*项)(p0): k a_ktp, v a_v? , v0 a?_v

项一般是 _1 i1 的(正)整数，每个都有 load/dump/size (r,w,sz) 操作，如果 NO==sz ，之后的项 a_ktp 内p 都是不定的，不能在创建时计算 p+=it.sz 的结果

v0 在有更改时创建， w() 时只有 v0[i]!=NO 的项被写入

其实 bp.p=p1 是支持 p1>bp.n 的值（空悬指针）的，这种写入被化为未来任务。 原位>p1 的值会被右移（以此支持数组的增长、ELF节指向的数据等右位引用），这种移动类似 bp.align=4 ，不影响地址回填

基础类型与 import struct 对应：

- xcbB?hHiIlLfde
- 无 i1 i1 _1 q1 i2 _2 iIlL-以此类推 f4 f8 无
- 第二位是其字节长度，如 i1 sizeof(char)==1
- sp
- BAry(_1,end="\0",eq=Eqv.chars("ascii")) BAry(_1,sz=_1)
- nNP
- iS _S pi4(C-FFI,某i4地址)
- i16 _16
- 我们默认惰性读写，无需 iter_unpack ，暴露buf参数，无需 pack_into,unpack_from


支持单位和函数选参UI的计算器

=利息(钱,年,P, 固定/滚利) 判(旗, 固定,钱*年*P,  滚利,累计以(*(P), 1~年,钱) )

累计以(*(0.0325), 1~5, 5w)

源-至 单位换算有专页UI，至源互换、多至都可用
单位比率换算以内部函数 单位(, 重|长|时|速|温|面|体, 单位名) 加后缀格式支持，若参数名是单位，它从默认单位下数值自动换算。进制换算基于文本参数，如 单位还(ff00, 数制,16)
为计算性能，(用户定义)函数名与开括号被存作单字符，中缀可隐式作为前缀，调用提供参数不够如： *(1,2)==2 ， *(1)(2)==2 以闭包形式待参齐，减号则是 +(-n)。
调用可以内联,也可选输出过程

=Hsin 是函数 sin 的帮助，它的旗参数提供可选动作，默认得文本+示例输入
说(你好世界) 文本可不带引号，听说函数可用在惰性求参的 判() 里。

长幼亲子爱
父母夫妻儿女
兄弟姐妹

+-^v&
fmpqabLlRr
配对表 配对列 嵌套列

方向 称他 称我 查单字链
模式 男+女/ 男 女 枚举

亲子 子亲/爱子 子长幼=长+幼 不支持婚外情 单=长子
长*=不计算大哥、二哥等出生序
长幼*=无年龄义
爱爱*=消除偶数个，不支持婚外情

爱亲=[[公公,婆婆],[岳父,岳母]]
子爱=[[?,儿媳],[女婿,?]]


filt={req-> if(req.path.starts("/lock")&&!req.id)return true; }
doc.body.tail=edit(img, im1=> )

比如 /users/make 的路径肯定是 PUT 的，那为什么还要这种"/make"呢，直接连着 /list 一起支持了，通过 HTTP verb 是 post/get/put/delete 区分 CRUD ，实例用路径ID区分，或者放 ?id= 里，嘛总之就是 用户,商户,商品 这些类别,的实例 都有个统一的路径，结合 ORM SQL语句都不用写列


有两个树模型用于求值，tvr tree-childeval-ret 和逆波兰栈 ops 。逆波兰算符重排可以单步求值、可以显示过程，就是无法 a&&print() 这种部分求值

tvr 是静态类型 Visitor 判断树点的改进，它可以有解释/检查的多操作、能在渐进重写(即求值)语法树时通知临时结果，也可以 r(v(0)? v(1):v(2)) 这样向上层提供值，或是参考不递归的 t[0]

经过熟悉我也了解如何分割语法解析法与内部表示，也可以选择完全用 tvr 模型，但“不切实际”(因为绝大部分编译器不在乎)地说 ops 比 tvr 更省内存，表达式语言也很优雅，return, break 的结构都可以通过栈,回填直接作成表达式，无论是解释或编译ops更好

LR 解析也不好，从顶 +到末端 ** 层，都是 A=A+A|B ;B=C*C|D 这种废话连篇的尾缀或替换。如果我们有个简单优美的方法，为什么要所谓优雅的优化来解决呢？

虽然 (q?{print(A)}:{print(B)})() 的闭包是可用的（编译时也类似这种情况），像 Lisp 之所以能有 lambda cond 等，最根本不是这俩符号的值特殊，而是不先算它们的参数，不会语法错误；不然它们根本无意义。 tvr 能做到，ops 的嵌套列表模式也能做，但就没优势了。

不过后来我想到 ops 本身也是加了“特殊右项” “同符号合并”等优化的。通过为 && 等特殊算符添加右项为子队列可以实现惰性计算。Lua 的递归遍历法虽然比波兰不能暂停，但非常适合这种高度预计算的情况
