函数式是一种编程范式，或者说定义一个程序的基本表达法，React, Vue, Flutter Elm 啊这些也都挺捧的，实际上我也经常用函数式

map, partition

不过我不是来当好好先生的，实际上我今天会有点锋芒毕露

融合了数据的动作

比起叫函数式，我刚刚的操作其实更类似面向对象一些，只不过没把它写成这样：(哔)

为啥这么说？因为这个里引用了一个外部的、单独的函数内不可见的局部变量，所以它单纯是函数吗？是，但它的生命周期就和外层这个相关了，后生，不后死。

这和 C 宏有点像啊，但那个是文本上的，展开为一小段 for 之类的常用结构，它必然是一对括号的形式，不可能有值、能 return 或者连着几个括号；它如果接收函数，也可以是一段变量参数不完整的表达式，它只能看见调用处所能看见的变量，不能让函数依不属于自己的变量而变化。

函数式语言一般都支持函数值、递归先于循环、部分参数；惰性求值、不可变数据、模式匹配

求值呢就是 11 2 的化简动作，基于 f(x,x1) 这种调用有传值、惰性、传表达式三种顺序，传值的好处是参数表达式的作用域就在当下，惰性一般可以消除一些重复计算和剪枝，传值也称应用(调用)序

函数式属于定义式编程的一种——定义做什么而不是算法操作细节，意味着你可以缩减击键和行数，意义我不想多说，给你个眼神自己体会。

const getServerStuff = function (callback) {
  return ajaxCall(function (json) {
    return callback(json)
  }/*x=>callback(x); x=>f(x) == f*/)
}

// 只针对当前的 Article 列表
const validArticles = function (articles) {
  return articles.filter(function (article) {
    return article !== null && article !== undefined
  })
}

// 针对任何项目的列表
const compact = function(xs) {
  return xs.filter(function (x) {
    return x !== null && x !== undefined
  })
}

物理命名法那期我也应该讲了，动词是针对非特例化的数据模式而不是某些特定数据项的，所以对于子程序类型重于名字，甚至能当名字用。


const curry=(f,a0=[])=>(...a)=>(
  n(a0)>=n(f)? f(...a0) : curry(f,a)
),n=o=>o.length

啊我不是讲历史的，Haskell Curry 是个人名不多说了，这就是左部优先的部分调用，等右侧参数收集完才真正执行，比如 [].filter(curry(x=>e=>e==x)(1)) 通过提供已知的目标 x 和 filter 过程的变量 e ，改变 x 可以造出一大堆相等测试的翻版，当然这个也不太常用（没箭头函数规范），就是带感。

对了我说 f=match(/wt(f)/g); f("wtf")[0]=="f" ; f=subs("guy","亲"); f("hello, guy!")=="hello, 亲!" 里两次 f 的类型分别是 String->String[] 和 String->String 可能会有力些。

然后就是争议大的 compose 及 pointfree (不写明参数编程) ，我懒得讲咯

不过有一点我非常满意就是 Kotlin 带来的 let,also,apply,run 能减轻大量重复 a.x, a.y 调用，直接 a.apply{listOf(x,y)} ，非常完美的利用了函数式的优点、规避了它和 JS,VB with 语法的不规范。

刚刚我们说了 Scheme 比老套编程语言 Lisp 牛逼的一点，再谈谈纯函数，正事啊。

纯函数：「一个子程序的行为和返回值，只依据其形式参数而变化，不因外部变量/接口改变」

引用透明就是把描述目标从这子程序变成表达式，说着更灵活些。

那如果「调用」一个程序带来的后果在语言内是不可见、即不可描述的，或者它超过了自身封闭的作用域，我们就可以说这程序是「不纯」的。

文件系统/stdIO、数据库、HTTP 都可能是副作用

let a=1 in (f a) 纯否？看着有赋值啊，但它是 (f 1) ，没有重赋值本质是别名，纯的。当然无副作用的函数结果不改变，let a=f() 这种实际也就没存储结果的语义，引用透明。

也就是 print, a=v; 等在基于语言求值序(左先右后)下是不纯的，而且可能是控制流的选择执行，但如果你用惰性求值、内部排序的数据去执行它，很多人会觉得它纯，明明做了 IO 却仍是纯函数，比如 [1,2,3].forEach(cond(eq(2), con.log)) 隐含 eq(2,参数1) 若是则 log ，log 算不算纯函数？对 forEach 来说其实是的，因为只有到第二项才去计算它

其实纯根本就不是有没有 stdIO 的事，而是限制数据可变范围的事。

打个比方， join 有缓冲区 append 的实现，也有递归拼接的实现，当我们只看函数类型时其实是没有纯不纯问题的，一些语言在类型检查上用了特别的手段去区分操作语义和尾递归的重组语义，所以你看是不是，「纯」的算法成了一个标签，就像所谓的处女情结。

假设我们设计一个学员名单应用，很简单就是存一个 [{name:String,age:Int}] 列表，但是我们要能添加(向列表级)或者编辑，这是不是在修改数据？数据是不可变的啊。

于是我们的应用“渲染函数”有了参数 app(state) ，然后事件更新呢就是合并，重以新的 state 调用 app 得到新 UI 。

不是说不能有变量吗？wait, 我们没做 o[k]=v; 的操作，如果描述为 set(o,k,v) ，至少 set(st,"k",1) 后 st 上的所有属性都没变，或者说 set() 的修改是在其副本上执行的，新版在封闭作用域内作为返回值

符合刚刚的定义啊，这个数据在 app 子程序活跃时没有任何变动，所以 app 是纯函数。我们只是把 click=push 的副作用，变成 click=merge&app(new-st) 的重渲染，相当于封装出了个“事件-状态更新”函数，从三参 o[k]=v 变成 change{o,k,v} 的「赋值于副本」函数，或者索性把复制副本的也做进来，整体逻辑会像是这样：

let st;while(st=app(st));

root f v=root f (f v)
root _ ()=()

于是 app 就兼具渲染和取第一个事件的职责，当然这不意味着事件就一定导致数据更新，弹框之类的不需要这层来重写 app 的参数

这个例子是很现实的，但可能不是纯函数式爱好者最喜欢给你分享的例子（笑）

如果扩展一下就成 SMUV 状态,消息-更新,视图渲染多事件模型了，事实上除 DOM 外 HTTP,SQL,WebSocket 也会带来消息事件，然后我们不得不对状态做些(filter,map,sort;slice,reduce 等)更新，接着据它渲染视图什么的

React,Elm 等函数式组件框架会这么想，这在一定程度上对随数据更新的 UI 有帮助，而且渲染列表某单项的结果也能缓存

其实我觉得还好吧，就是它们过度设计做得太足了，一大堆 boilerplate

「纯」这字眼暗含了所有子程序都只应消费/参考参数并生成值的约束，数据可变性的范围，纯函数式和定义式本身没有充要关系，纯函也能写表述式，不纯也能做定义式编程。

爱好数学的人被认为是「抽象能力很强」，可抽象能力强的一定是为数学吗？好像也不见得吧。混搭，永远地神~

这个世界上真的有可以只用一个值表达（没有副作用）的事情吗？如果你的程序需要一打变量，你也可以用 {} 来作为单个值储存，但为什么不把它们切分开去方便修改呢？是因为你的程序大到足以容纳下这个世界，所以变不变无所谓，不能再拆分对吗？

调用(应用) 的推导过程不需要你往「栈」上放东西吗？求值的基础也不需要副作用吗？递归分配了存储空间，可以理解为一步「操作」吗？

拆成更细的操作，而不是混在一起

当我们用函数式，其实比起在寻找对问题的简单解法，更多是在解决你的问题映射到函数式世界里带来的更多问题，包括繁琐多名词的 API 或模型异化给你的额外心智开销；我觉得编程只是你描述问题以及其解法、结果的一种手段，它本身不该带来任何麻烦事。一句话的事。

如果你是对这种问题感兴趣，去研究(过)了下，欢迎评论区分享我有空也会帮你；如果你只是没有信心，欢迎来我这学看得见摸得着的技术，它也能给你带来自信和眼界，咱先跑再飞。

如果你坚信这种编程方法能，想说服我收回成见（当然我不接受智商类不理智的人身攻击啊），欢迎你拿5分钟能说明白的有趣算法来怼我啊，如果你，请便

面向对象语言的问题是，它们永远都要随身携带那些隐式的环境。你只需要一个香蕉，但却得到一个拿着香蕉的大猩猩...以及整个丛林 --Erlang 作者

函数式语言设计者的问题是，他们明明懂得隐式变量环境以及副作用的重要性，却仍声称应用应该要那一套浮夸的的纸面路径链去解决来源于过度设计和冗余代码的作用域污染
